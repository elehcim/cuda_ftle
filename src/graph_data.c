/* graph_data.c
 *
 * A replacement plotter for simple FTLE plots. 
 * PLPlot and GNUPlot take a long time when making
 * these color maps, since they attempt to fill
 * in polygons on top of each other, like a topo
 * map. Here, I blitz through and color every pixel
 * individually.
 *
 * Limitations: End image dimensions will be the same as the
 * grid used in the datafile.
 *
 * No support for non-1-to-1 mapping of pixels to datapoints.
 *
 * Datafile must have monotonically increasing x and y, or
 * a sawtooth-looking X/Y. Can't have any bits where the next
 * x/y value is less than the directly previous one.
 *
 * Advantages: Fast as hell. PLPlot will take 3 minutes to 
 * plot a 1024x1024 grid with 255 color levels, this will do 
 * 2048x2048 in 7 seconds, and is bound (only?) by disk bandwidth.
 *
 * v 0.1
 * Raymond Jimenez
 * <raymond@naru.wsyntax.com>
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stddef.h>
#include <math.h>
#include <getopt.h>
#include <ctype.h>

#include <gd.h>

#include "uthash.h"

int verbose = 0;

struct xy_point {
  float x;
  float y;
  float z;
  UT_hash_handle hh;
};

const static struct option longopts[] = {
  {"verbose", no_argument, &verbose, 'v'},
  {"help", no_argument, NULL, 'h'},
  {"output", required_argument, NULL, 'o'},
  {"ftle", required_argument, NULL, 'f'},
  {"reverse-ftle", required_argument, NULL, 'r'},
  {"tracer", required_argument, NULL, 't'},
  {0,0,0,0}
};

void print_help(void)
{
  fprintf(stderr, "graph_data v0.1\n\n\
graph_data takes several command line options:\n\
-v (--verbose) \t\t\t\tIncrease verbosity (only once).\n\
-h (--help) \t\t\t\tThis is it.\n\
-f (--ftle) <datafile>\t\t\tRead this FTLE datafile (as generated by computeFTLE(_CUDA)) (default=ftle.data).\n\
-r (--reverse-ftle) <datafile>\t\tRead this reverse FTLE field (disabled by default).\n\
-t (--tracer) <tracerfile>\t\tRead this tracer file (disabled by default).\n\
-o (--output) <output>\t\t\tPlace the output PNG here. (default=ftle.png)\n");
  fprintf(stderr, "\nPlease note that this program is only guaranteed to work\n\
with sets of files output by a single computeFTLE(_CUDA) run.\n\
Mix and match and it will probably crash.\n");
  fprintf(stderr, "\nWritten by Raymond Jimenez <raymondj@caltech.edu>.\n");
  exit(1);
}

inline void hsv_to_rgb(float h, float s, float v, int *r, int *g, int *b)
{
  int i;

  float p,q,t,f;

  i = ((int)floorf(h/60.0))%6;
  f = h/60.0 - i;

  p = v * (1.0 - s);
  q = v * (1.0 - (f * s));
  t = v * (1.0 - ((1.0-f)*s));
  
  switch (i) {
    case 0:
      *r = 255.0*v;
      *g = 255.0*t;
      *b = 255.0*p;
      break;
    case 1:
      *r = 255.0*q;
      *g = 255.0*v;
      *b = 255.0*p;
      break;
    case 2:
      *r = 255.0*p;
      *g = 255.0*v;
      *b = 255.0*t;
      break;
    case 3:
      *r = 255.0*p;
      *g = 255.0*q;
      *b = 255.0*v;
      break;
    case 4:
      *r = 255.0*t;
      *g = 255.0*p;
      *b = 255.0*v;
      break;
    case 5: 
      *r = 255.0*v;
      *g = 255.0*p;
      *b = 255.0*q;
      break;
  } 


  return;
}

/*

inline int tracer_mask(float x0, float y0, float x, float y)
{
  if( (sqrt(x0*x0+y0*y0) < 0.1) || (sqrt(x0*x0+(y0-0.5)*(y0-0.5)) < .1) )
    return 1;
  else
    return 0;
}

inline int ftle_mask(float x, float y)
{
  if(sqrt(x*x+y*y) < 1.0)
    return 1;
  else
    return 0;
}

*/

inline int ftle_mask(float x, float y)
{
  return 1;
}

inline int tracer_mask(float x0, float y0, float x, float y)
{
  return 1;
}


int main(int argc, char *argv[])
{
  char buffer[256];
  char *sep,*sepold;
  FILE *infile,*outfile;

  gdImagePtr im;
 
  float *x,*y,*z;
  float *x0,*y0; // used for tracers only

  float x_min,x_max,y_min,y_max,z_min,z_max;
  float rev_z_min, rev_z_max;
  float *x_pos,*y_pos;

  float x_div,y_div,z_div;
  float rev_z_div;

  float tmp;
  int npoints = 0;
  int rev_npoints = 0;
  int ntracers = 0;
  int x_points = 1, y_points = 1;
  int i,j,k,l;  
  int rgb1[3],rgb2[3],rgb3[3];

  char datafile_default[] = "ftle.data";
  char *datafile = &datafile_default[0];

  char *revdatafile = NULL;

  char *tracedatafile = NULL;

  char graphfile_default[] = "ftle.png";
  char *graphfile = &graphfile_default[0];

  struct { float x; float y; } lookup_key;
  struct xy_point *grid = NULL;
  struct xy_point *grid_reverse = NULL;
  struct xy_point *point,*rev_point;
  int keylength;

  /* begin parsing our command line arguments */

  while((i = getopt_long(argc, argv, "vo:r:f:t:h", &longopts[0], NULL)) != -1)
  {
    switch(i)
    {
      case 'v':
        verbose = 1;
        break;
      case 'o':
        graphfile = optarg;
        break;
      case 'r':
        revdatafile = optarg;
        break;
      case 'f':
        datafile = optarg;
        break;
      case 't':
        tracedatafile = optarg;
        break;
      case 'h':
        print_help();
        break;
      case '?':
        if(isprint(optopt))
          fprintf(stderr, "Unknown option '-%c'.\n", optopt);
        else
          fprintf(stderr, "Unknown option character \\x%x.\n", optopt);
        print_help();
        exit(1);
        break;
      default:
        break;
       
    }
  }
  

  /* end */
  /* begin reading in the files and processing */

  infile=fopen(datafile,"r");
  if(!infile)
  {
    fprintf(stderr, "Could not open FTLE data file!\n");
    exit(1);
  }

  while(fgets(buffer,255,infile))
    npoints++;  

if(verbose)
  printf("We have %i points.\n", npoints);

  fseek(infile,0,SEEK_SET);

  x = (float *)malloc(sizeof(float)*npoints);
  y = (float *)malloc(sizeof(float)*npoints);
  z = (float *)malloc(sizeof(float)*npoints);

  if(!x || !y || !z)
  {
      fprintf(stderr, "Error occured allocating memory for x/y/z!\n");
      exit(1);
  }
 
  i=0;
  while(fgets(buffer,255,infile))
  {
    sep = buffer;
    sepold = strsep(&sep,"\t");
    if(!sepold)
      {  fprintf(stderr, "Error reading in x value!\n"); exit(1); }
    x[i] = (float)strtod(sepold, NULL);
    sepold = strsep(&sep,"\t");
    if(!sepold)
      {  fprintf(stderr, "Error reading in y value!\n"); exit(1); }
    y[i] = (float)strtod(sepold, NULL);
    sepold = strsep(&sep,"\t");
    if(!sepold)
      {  fprintf(stderr, "Error reading in z value!\n"); exit(1); }
    z[i] = (float)strtod(sepold, NULL);
    i++;    
  }

  if(ferror(infile))
  {
    fprintf(stderr, "Something went wrong when reading the datafile.\n");
    exit(1);
  }

  fclose(infile);

  x_min=x_max=x[0];
  y_min=y_max=y[0];
  for(i=0;i<npoints;i++)
  {
    if(finitef(z[i]))
    {
      z_min=z_max=z[i];
      break;
    }
    if(i==npoints-1)
    {
      fprintf(stderr, "No valid datapoints in the forward FTLE set!.\n");
      exit(1);
    }
  }  

  for(i=0;i<npoints;i++)
  {
    if(x[i] > x_max)
      x_max = x[i];
    if(x[i] < x_min)
      x_min = x[i];

    if(y[i] > y_max)
      y_max = y[i];
    if(y[i] < y_min)
      y_min = y[i];

    if((z[i] == -1.0/0.0) || (z[i] == 1.0/0.0) || isnanf(z[i]) )
      z[i] = -1.0/0.0;


    if(z[i] > z_max)
      z_max = z[i];
    if(z[i] < z_min && z[i] != -1.0/0.0)
      z_min = z[i];

  }

  // so for now, i'll make an argument that all datafiles must
  // be monotonically increasing on x/y or sawtooth-looking.
  // use sort(1) to fix this. but! this is best used ONLY
  // with the programs in this distribution

  z_div = ((z_max-z_min)/(float)(255-1));



  i=0;
  tmp=x_min;
  while(i<npoints)
  {
    if(x[i]>tmp)
    {
      x_points++;
      tmp=x[i];
    }
    if(x[i]==x_max)
      break;
    i++;
  }

  i=0;
  tmp=y_min;
  while(i<npoints)
  {
    if(y[i]>tmp)
    {
      y_points++;
    }
    if(y[i]==y_max)
      break;
    i++;
  }

  x_pos = (float *)malloc(sizeof(float)*x_points);
  y_pos = (float *)malloc(sizeof(float)*y_points);

  i=0;  
  j=1;
  tmp=x_min;
  x_pos[0]=x_min;
  while(i<npoints)
  {
    if(x[i]>tmp)
    {
      tmp=x[i];
      x_pos[j] = x[i];
      j++;
    }
    if(x[i]==x_max)
      break;
    i++;
  }

  i=0;  
  j=1;
  tmp=y_min;
  y_pos[0]=y_min;
  while(i<npoints)
  {
    if(y[i]>tmp)
    {
      tmp=y[i];
      y_pos[j] = y[i];
      j++;
    }
    if(y[i]==y_max)
      break;
    i++;
  }

  x_div = (x_max-x_min)/(float)x_points;
  y_div = (y_max-y_min)/(float)y_points;

if(verbose)
  printf("Max/Min: (%f,%f)-%f (%f,%f)-%f (%f,%f)-%f\n", x_max, x_min, x_div, y_max, y_min, y_div, z_max, z_min, z_div);

if(verbose)
  printf("Our array is apparently %ix%i.\n", x_points, y_points);



  // see uthash documentation
  keylength =   offsetof(struct xy_point, y) 
              + sizeof(float)
              - offsetof(struct xy_point,x);

  for(i=0;i<npoints;i++)
  {  
    point = (struct xy_point *)malloc(sizeof(struct xy_point));
    point->x = x[i];
    point->y = y[i];
    point->z = z[i];

    HASH_ADD(hh,grid,x,keylength,point);
  }

  free(x);
  free(y);  
  free(z);

if(verbose)
  printf("There are %u number of items in the grid.\n", HASH_COUNT(grid));

/* process the reverse datafile in the exact same manner. START! */

  if(revdatafile)
  {
    infile=fopen(revdatafile,"r");
    if(!infile)
    {
      fprintf(stderr, "Could not open reverse FTLE data file!\n");
      exit(1);
    }


    while(fgets(buffer,255,infile))
      rev_npoints++;  
   
    if(rev_npoints!=npoints)
    {
      fprintf(stderr, "Reverse FTLE and forward FTLE files do not match up! Please try with a proper pair.\n");
      exit(1);
    }

    fseek(infile,0,SEEK_SET);

    x = (float *)malloc(sizeof(float)*npoints);
    y = (float *)malloc(sizeof(float)*npoints);
    z = (float *)malloc(sizeof(float)*npoints);

    if(!x || !y || !z)
    {
        fprintf(stderr, "Error occured allocating memory for reverse x/y/z!\n");
        exit(1);
    }
 
    i=0;
    while(fgets(buffer,255,infile))
    {
      sep = buffer;
      sepold = strsep(&sep,"\t");
      if(!sepold)
        {  fprintf(stderr, "Error reading in x value!\n"); exit(1); }
      x[i] = (float)strtod(sepold, NULL);
      sepold = strsep(&sep,"\t");
      if(!sepold)
        {  fprintf(stderr, "Error reading in y value!\n"); exit(1); }
      y[i] = (float)strtod(sepold, NULL);
      sepold = strsep(&sep,"\t");
      if(!sepold)
        {  fprintf(stderr, "Error reading in z value!\n"); exit(1); }
      z[i] = (float)strtod(sepold, NULL);
      i++;    
    }

    if(ferror(infile))
    {
      fprintf(stderr, "Something went wrong when reading the reverse datafile.\n");
      exit(1);
    }

    fclose(infile);

    for(i=0;i<npoints;i++)
    {
      if(finitef(z[i]))
      {
        rev_z_min=rev_z_max=z[i];
        break;
      }
      if(i==npoints-1)
      {
        fprintf(stderr, "No valid datapoints in the back FTLE set!.\n");
        exit(1);
      }
    }  


    for(i=0;i<npoints;i++)
    {
      if((z[i] == -1.0/0.0) || (z[i] == 1.0/0.0) || isnanf(z[i]) )
        z[i] = -1.0/0.0;

      if(z[i] > rev_z_max)
        rev_z_max = z[i];
      if(z[i] < rev_z_min && z[i] != -1.0/0.0)
        rev_z_min = z[i];
    }

    rev_z_div = ((rev_z_max-rev_z_min)/(float)(255-1));

    // NB: we depend on the forward and reverse FTLE fields to have the
    // -exact- same grid of points, so that the hash lookup doesn't fail
    // terribly. all bets are off if the files don't line up!
  
    for(i=0;i<npoints;i++)
    {  
      point = (struct xy_point *)malloc(sizeof(struct xy_point));
      point->x = x[i];
      point->y = y[i];
      point->z = z[i];

      HASH_ADD(hh,grid_reverse,x,keylength,point);
    }

    free(x);
    free(y);  
    free(z);


  }

/* END! done processing reverse datafile. */

/* begin processing tracer datafile */
  if(tracedatafile) 
  {
    infile=fopen(tracedatafile,"r");
    if(!infile)
    {
      fprintf(stderr, "Could not open FTLE data file!\n");
      exit(1);
    }

    while(fgets(buffer,255,infile))
      ntracers++;  

 if(verbose)
    printf("We have %i tracers.\n", ntracers);

    fseek(infile,0,SEEK_SET);

    x = (float *)malloc(sizeof(float)*ntracers);
    y = (float *)malloc(sizeof(float)*ntracers);
    x0 = (float *)malloc(sizeof(float)*ntracers);
    y0 = (float *)malloc(sizeof(float)*ntracers);

    if(!x || !y)
    {
        fprintf(stderr, "Error occured allocating memory for tracers!\n");
        exit(1);
    }
 
    i=0;
    while(fgets(buffer,255,infile))
    {
      sep = buffer;
      sepold = strsep(&sep,"\t");
      if(!sepold)
        {  fprintf(stderr, "Error reading in n value!\n"); exit(1); }
      sepold = strsep(&sep,"\t");
      if(!sepold)
        {  fprintf(stderr, "Error reading in x0 value!\n"); exit(1); }
      x0[i] = (float)strtod(sepold,NULL);
      sepold = strsep(&sep,"\t");
      if(!sepold)
        {  fprintf(stderr, "Error reading in y0 value!\n"); exit(1); }
      y0[i] = (float)strtod(sepold,NULL);

      sepold = strsep(&sep,"\t");
      if(!sepold)
        {  fprintf(stderr, "Error reading in x value!\n"); exit(1); }
      x[i] = (float)strtod(sepold,NULL);
      sepold = strsep(&sep,"\t");
      if(!sepold)
        {  fprintf(stderr, "Error reading in y value!\n"); exit(1); }
      y[i] = (float)strtod(sepold,NULL);

      i++;    
    }

  }


  /* begin drawing code */
 
  im = gdImageCreateTrueColor(x_points,y_points);     


  /* begin the fun stuff. pixel blitting! */

  for(i=0;i<x_points;i++)
  {
    for(j=0;j<y_points;j++)
    {
      lookup_key.x = x_pos[i];
      lookup_key.y = y_pos[(y_points-j-1)];
      
      if(!ftle_mask(lookup_key.x,lookup_key.y))
      {
        gdImageSetPixel(im,i,j,gdImageColorResolve(im, 255, 255, 255));
        continue; // don't waste our time on this pixel. seriously.    
      }

 
      HASH_FIND(hh,grid,&lookup_key.x,keylength,point);

      if(!point)
        {  fprintf(stderr, "Error occured when plotting points!\n"); exit(1); }
      k = (int)(ceilf((point->z-z_min)/z_div));
      l = 0;

      if(revdatafile)
      {
        HASH_FIND(hh,grid_reverse,&lookup_key.x,keylength,rev_point);
        if(!point)
          {  fprintf(stderr, "Error occured when plotting reverse points!\n"); exit(1); }
        l = (int)(ceilf((rev_point->z-rev_z_min)/rev_z_div));
        if(rev_point->z == -1.0/0.0)
          point->z = -1.0/0.0;
  
  
        rgb1[0] = 255;
        rgb1[1] = 256-k;
        rgb1[2] = 256-k;
  
        rgb2[0] = 256-l;
        rgb2[1] = 256-l;
        rgb2[2] = 255;

        rgb3[0] = (1.0-((float)l/256.0))*(rgb1[0])+((float)l/256.0)*(rgb2[0]);
        rgb3[1] = (1.0-((float)l/256.0))*(rgb1[1])+((float)l/256.0)*(rgb2[1]);
        rgb3[2] = (1.0-((float)l/256.0))*(rgb1[2])+((float)l/256.0)*(rgb2[2]);
   
      } else 
      {
        rgb3[0] = 255;
        rgb3[1] = 256-k;
        rgb3[2] = 256-k;
      }

      if(point->z == -1.0/0.0)
        gdImageSetPixel(im,i,j,gdImageColorResolve(im, 0, 0, 0));
      else
        gdImageSetPixel(im,i,j,gdImageColorResolve(im, rgb3[0], rgb3[1], rgb3[2]));
    }
  }

  if(tracedatafile)
  {
    for(i=0;i<ntracers;i++)
    {
      if(!tracer_mask(x0[i],y0[i],x[0],y[0]))
        continue; // don't waste time on this guy.

      k = (int)rintf((x[i]-x_min)/(x_div));
      l = (int)rintf((y_max-y[i])/(y_div));
      tmp = 360.0*((float)i/(float)ntracers);
//      printf("%f\n", tmp);
      hsv_to_rgb(tmp, 1.0, 0.9, &rgb1[0], &rgb1[1], &rgb1[2]); 
      if( ((k>0) && (k<x_points)) && ((l>0) && (l<y_points)))
      {
//        gdImageArc(im, k, l, 4, 4, 0, 360, gdImageColorResolve(im, 0, 0, 0));
        gdImageRectangle(im, k-1, l+1, k+1, l-1, gdImageColorResolve(im, rgb1[0],rgb1[1],rgb1[2]));
      }
    }

  free(x);
  free(y);
  free(x0);
  free(y0);
	
  }

 
  outfile=fopen(graphfile,"wb");
  if(!outfile)
  {
    fprintf(stderr, "Could not open graphing file!\n");
    exit(1);
  }

  gdImagePng(im, outfile);  
  
  fclose(outfile);

  gdImageDestroy(im);

  while(grid)
  {
    point = grid;
    HASH_DEL(grid,point);
    free(point);
  }

  if(revdatafile)
  {
    while(grid)
    {
      point = grid_reverse;
      HASH_DEL(grid_reverse,point);
      free(point);
    }
  }

  exit(0);
}

